The polygonmanager consists of 4 main classes that correspond to its 4 objects of responsibility: the rectangle, the square, the triangle ad the regular polygon. I structured the classes this way (instead of, for example, primarily functionality), because, while they share specific properties (such as possessing a measurable area and perimeter), each one of these object types necessitates specific methods and properties that define those higher order ones. Consequently, each class has to contain its own properties methods that facilitate access to the properties they all have in common. The classes are only responsible for the modelling of their designated geometrical shapes. Hence, they tie in with the Single responsibility principle, according to which a class is only related to a single part of a programme’s functionality. In a broader picture, they could be used with other classes that, for example, get user input, process user input, and print output. 

Given the logical as well as operational relatedness of the different shapes, all of them implement the abstract class Polygons. Using an abstract class as a parent for the related child classes has several advantages with regard to the broader structure and possible extensions of the code. First of all, it is a higher level control mechanism, as the use of abstract methods is a means to contract the child classes to the use of (adapted versions of) specific methods. In this case, I used it as as a medium to contract all polygon classes to two separate interfaces, the AreaOpertionsInterface and the PerimeterOperationsInterface. These interfaces oblige all classes (or their developer) to incorporate the main abstract methods that the polygonmanager is using: one to calculate the area of the shape, and another to calculate its perimeter. Interfaces are hence a means to add the control to an abstract layer, corresponding to the Dependency inversion principle. Different modules can thus connect through abstraction, e.g. through typehinting. This could come in handy for this application when considering other shape classes that would implement the same interfaces, such as a Circle class, which might be used by other modules interchangeably. 

I chose not to implement the abstract methods contained in the interfaces directly in the abstract Polygons class, so as to keep the code modular, flexible and open to changes. This way, it is easy to grasp the abstract structure underlying the classes, but also to precisely add functions where the area or the perimeter is concerned, such as a function to change the area of a polygon. Furthermore, the interfaces could also be used for other shapes that do not belong to the polygon abstract class but that can also use area and perimeter functions, such as a Circle class. The separation between the interfaces corresponds to the Interface segregation principle. 

Among the polygons, there are some more refined hierarchical structures. The square is extending the class of the rectangle, as the two are not only related or similar, but in fact share the same properties and methods. As the square is a logical subcategory of the rectangle, there is no need for it to have its own methods, it can inherit and thus operate with the parents ones. This inheritance corresponds to the Liskov substitution principle: its method mirrors the parent’s methods, and it accepts the same values when they are passed on to it. An instance of square can, as a subtype of rectangle, correctly operate with the exact same functions as an instance of the parent class. 
The only change I made is within the constructor class: the one property that distinguishes the square from other rectangles is the fact that width and height are the same, so they are assigned using only one parameter. This way, the square can use all the parent methods as it still possesses the same properties as the parent class, yet it is precisely defined using its distinguishing property. 

Another case where two classes use one function is the calculation of the area of a triangle. So as to not repeat myself (DRY), I chose to have both the triangle class itself and the regular polygon incorporate an abstract interface, the triangleAreaCalculator. The purpose of this class is thus to provide the method that both triangle and regular polygon instances can use for the calculation of their areas. I decided to implement it in this way so as to make sure that it is these classes, and only these that have access to the method and to avoid any name collisions. Object inheritance (from triangle to regular polygon) would not have been a good decision in this case, since the classes are not logically related in the same way, and they do not share methods, they just use similar ones. It would not be possible to reuse their methods and exchange the parent for the child class, as the Liskov substitution principle determines.

Other developments in the architecture of the application were choices of a more contextual nature. 
As an example, the code has to be useful for mathematical operations. This is relatively straightforward when it comes to rectangles, but a more complicated topic when it comes to triangles and regular polygons. In case of regular Polygons, I limited the user input to two parameters, even though three would be necessary to execute an areacalculation. That is to make sure that any input will always generate the values of a real polygon, and the calculations work accordingly.  As a consequence, one parameter is calculated from the other two before a calculation is executed. 
At the same time, I kept all calcArea() and calcPerimeter() functions as general as possible, to make sure that the application can be extended and reuse these functions (if, for example, there are more options for different input parameters and to calculate missing values). For the polygon, I thus added an if-statement to check whether or not the variable is defined, so it stays open for extensions as other additional calculations. This corresponds to the open-closed principle: the classes can be used by other modules and are thus closed, yet they can still be extended, e.g. by adding different calculations of other lengths.

The methods that all polygon classes possess should be called by the same name, as this facilitates a structured access. This way, their use becomes more modularised and simpler when the application is extended. Using dependency injection, other classes can thus rely on calcArea() and calcParameter() while staying flexible. Importantly, the outside classes can remain completely ignorant of the differences between the polygons (which does not matter to them), and only use their similarity. 

In this application, an exception to the rule that greatly impacted the architecture was the case of the triangle class. To keep the functions as general and thus reusable as possible, I stuck to the most basic way to calculate area and perimeter. In the case of irregular triangles, the two require very different input parameters that cannot easily be derived from each other. I decided to let the user choose which one of the functions to use, so the application is not taking in the minimal number of values to make both functions work, but only the values that are needed to execute one of the functions.
Hence, to construct a triangle it is necessary to chain it to propertysetters to its constructor, according to the function in use. In this sense, my decision led to a flaw in the consistency of the application, as the method of this class now deviates from the methods of its related classes. In the long run, it might be more advisable to either change the parameters requested from the user, or to generally change the construction of all the different shapes towards an instantiation without values, and a setting of its properties afterwards. Given potential extensions of the application, such as the calculation of missing properties, this would be an advantage in terms of flexibility.

To make sure that the calculations are correct, the user input has to be validated. Furthermore, error messages (that might later be wrapped in objects) can also remind fellow developers of the specific code structure (such as to chain methods in case of the triangle). Here, switches and exceptions make sure that the variables that are used to create instances and use functions are positive integers or floats. I tested all the main functions for the calculations of area and perimeter once. Furthermore, for the Rectangle class I also added a dataProvider, so as to test more deeply including my validation. 